%%%%%%%%% Work in progress, version 1.1
% This set of macros is published under the LaTeX Project Public License:

% This software is copyright but you are granted a license which gives you, the
% "user" of the software, legal permission to copy, distribute, and/or modify
% the software. However, if you modify the software and then distribute it (even
% just locally) you must change the name of the software, or use other technical
% means to avoid confusion.

% For linguists only -- this set of macros uses the xypic-module  to draw 
% syntactic trees and similar graphical objects used in linguistics literature
% in LaTeX files.

%% Please send your bug reports, comments and suggestions to Ralf Vogel
%% (rvogel@ling.uni-potsdam.de). I hope this set of macros will be useful for
%% you. In case you make further use of these macros in some of your
%% programming, please do not forget to mention who you copied them from. 

%% This style file comes with a documentation, xyli-doc.tex, which 
%% contains further hints, comments, and examples.

%%
% General description: 
% The macros in this package model the construction of syntactic
% tree structures as a genuinely graphical problem: they contain two types of
% objects, BRANCHES and NODE LABELS, and these are positioned relative to a
% GRID. It is essential that each of these three elements is constructed
% independent of the other two, and hence they can be modified without
% unwanted side effects. This is, to my mind, the most important difference to
% other tree drawing macro packages, where, in particular, the label width often
% changes the angles of the branches. A second important advantage lies
% in the xypic package. xypic generates Metafont code, so the drawing of trees is
% not dependent on postscript specials, as, e.g., in ps-trees. Hence, no
% postprocessing is required. The trees generated by postscript specials can
% neither be seen in a dvi previewer (at least not in my current version of
% xdvi for linux), nor can they be taken over into a pdf file by pdflatex
% (but it works in dvi to pdf conversion with dvipdf, or ps to pdf conversion
% with ps2pdf). 
%%

%% Earlier xyling users:
% I tried to systematise the definitions of node labels and branches. The easy
% commands are now defined in terms of the kontrolled commands, i.e., \K is
% defined via \Kk etc. I also defined a general branching command, \Bkk in its
% most kontrolled version. It underlies all the branching commands. I redefined
% all old commands in terms of the new ones. You should not see a difference,
% however. The commands should be fully backwards compatible. Commands that have
% been renamed are included via simple \let instructions. Please check the list
% at the end of this file. If there is anything going wrong for you, or you miss
% a command that has been there earlier, please let me know. 

% load xyling -
% put the following into the preamble:
%
% \usepackage{xyling}

% here we start. First of all, we load the xy package, with all options
% (although most options might not be necessary), including use of colours: 

\RequirePackage[color,all,dvips]{xy}
\UseCrayolaColors

% IMPORTANT NOTE: 
% The use of the dvips option might cause branches to disappear when you
% preoduce a pdf file with pdflatex. If this is so, there are two ways of
% overcoming this:
%
% 1. erase the dvips option above, i.e., use instead:
% \RequirePackage[color,all]{xy}
% You will no longer be able to use coloured branches now, however.
%
% 2. create the pdf file via dvips and ps2pdf conversion. This is how the
% documentation pdf file is created.


% A tree is a simple macro of the form "\Tree{ ... }"
% It is an xymatrix, with "&" as column separator and "\\" as row separator,
% just like tabular:

\makeatother
\newcommand{\Tree}[2][0]{\raisebox{1ex}{\xymatrix @H=.3pc @W=2pc @R=2pc @C=#1pc {#2}}}
\newcommand{\Treek}[3][0]{\raisebox{1ex}{\xymatrix  @H=.3pc @W=2pc @R=#2pc @C=#1pc {#3}}}

% \Tree has an optional argument that can be used for changing the space between
% columns. The default is 0. A negative value makes the tree smaller,
% a positive value makes it wider. 

% Space between rows is set to a default of 2pc (defined in "@R=2pc"). \Treek
% gives you "k"ontrol over the distance between rows. \Treek{2}{} =
% \Tree{}. Values higher than 2 raise the row distance, smaller ones shrink it. 

% You can use \Tree and \Treek for objects other than syntactic trees, of
% course. Be it phonological structures or simply any other graphical object
% that mixes words and lines in a graphical way. 

% @R=2pc is fine for one-row node labels, it might be too small for
% multi-row labels. LFG has trees with two-row labels. To include these, you
% will have to enlarge @R, define two-line labels, and branches originating from
% two-line labels. See below for an example.

% Node labels have the width of 2pc, as determined by the @W variable. This is
% nearly the width of two upright letters, like NP, VP etc. Extremely wide
% labels do not affect the matrix, because the node width is determined
% independent of the content of the node. If you need something different,
% change the @W value here.

% For the placement of node labels, we use the commands, \Kk, and \K. \Kk
% offers you full control over the horizontal and vertical placement of the
% label. 

\newcommand{\Kk}[3][0]{%
  \POS[]+(#1,-1.5)+(0,#2) \save*\txt{\textnormal{\rule[-6pt]{0pt}{18pt}#3}}
  \restore}

\newcommand{\K}[2][0]{%
  \Kk[#1]{0}{#2}}

% A node should usually be introduced with the command \K{...}. The optional argument
% is the horizontal adjustment in pc. Positive values move the label to the
% right, negative values to the left.
% Text is centered, both horizontally and vertically! 
% 1pc is about .5em in a 12pt font.

% I inserted a strut (i.e., \rule[-6pt]{0pt}) to make indexed labels behave like
% non-indexed ones. It works for up to 12pt fonts. Might have to be adjusted for
% other font sizes. 
% The node is inserted at  the center of the box, the center with respect to
% both the horizontal and the vertical dimension! Boxes with indices, like
% NP$_{i}$, are higher than an ordinary NP box. As a consequence of this, the
% NP of an indexed box would appear slightly higher than a sister node label
% without the strut. 

% \Kk offers full `k'ontrol over the vertical and horizontal dimension. The
% optional argument of \Kk is the same as that of \K, but there is an additional
% obligatory argument denoting the vertical adjustment. So the syntax is:
% \Kk[horizontal adjustment]{vertical adjustment}{node label}
% The command \Kk[1]{1}{VP} places the node VP 1pc right of and 1pc higher than
% the standard position. This in fact allows  you to put anything anywhere in
% the tree. You can add comments to the side of the tree etc. 

% Branch commands are inserted immediately after their dominating node. They are
% defined with respect to their target position in the matrix. We again start
% with the controlled version:

\newcommand{\Bkk}[3]{\POS[]-(0,4)+(#1)\ar@{-}[#3]+(0,2)+(#2)}

% The three arguments are: 1=adjustment of starting position, 2=adjustment of
% target position, 3=target location. The first two arguments are value pairs
% for the x- and y-axis: (horizontal,vertical).

% The third argument describes the target location of the branch, a string
% containing some of the following letters: d
% for one step down, l for one step left, r for one step right, u for one step
% up - but don't use u, because it will result in striking out the label name
% ... :-) branches always go downwards.  dr = 1 down, 1 right, drr = 1 down, 2
% right etc.

% \Bk only controls vertical adjustment of the starting and target
% positions, and keeps the horizontal dimension fixed:

\newcommand{\Bk}[3]{\Bkk{0,#1}{0,#2}{#3}}

% \Bk again has 3 obligatory arguments: the vertical adjustment of the starting
% position, that of the target position, and the target location. Positive value
% lifts the starting position, negative value lowers it.

% The simpler version, which you should normally use, only allows for the vertical
% adjustment of the starting position with its optional argument:

\newcommand{\B}[2][0]{\Bk{#1}{0}{#2}}

% an arrow version of \B:

\newcommand{\ARkk}[3]{\POS[]-(0,4)+(#1)\ar@{->}[#3]+(0,2)+(#2)}
\newcommand{\ARk}[3]{\ARkk{0,#1}{0,#2}{#3}}
\newcommand{\AR}[2][0]{\ARk{#1}{0}{#2}}


% Dashed, dotted and wavy versions of \B and \AR:

\newcommand{\Bkkdash}[3]{\POS[]-(0,4)+(#1)\ar@{--}[#3]+(0,2)+(#2)}
\newcommand{\Bkkdot}[3]{\POS[]-(0,4)+(#1)\ar@{.}[#3]+(0,2)+(#2)}
\newcommand{\Bkkwav}[3]{\POS[]-(0,4)+(#1)\ar@{.}[#3]+(0,2)+(#2)}

\newcommand{\Bkdash}[3]{\Bkkdash{0,#1}{0,#2}{#3}}
\newcommand{\Bkdot}[3]{\Bkkdot{0,#1}{0,#2}{#3}}
\newcommand{\Bkwav}[3]{\Bkkwav{0,#1}{0,#2}{#3}}

\newcommand{\Bdot}[2][0]{\POS[]-(0,4)\POS+(0,#1)\ar@{.}[#2]+(0,2)}
\newcommand{\ARdot}[2][0]{\POS[]\POS-(0,4)\POS+(0,#1) \ar@{.>}[#2]+(0,2)}

\newcommand{\Bdash}[2][0]{\POS[]-(0,4)\POS+(0,#1)\ar@{--}[#2]+(0,2)}
\newcommand{\ARdash}[2][0]{\POS[]\POS-(0,4)\POS+(0,#1) \ar@{-->}[#2]+(0,2)}

\newcommand{\Bwav}[2][0]{\POS[]-(0,4)\POS+(0,#1)\ar@{~}[#2]+(0,2)}
\newcommand{\ARwav}[2][0]{\POS[]\POS-(0,4)\POS+(0,#1) \ar@{~>}[#2]+(0,2)}

% Joost Kremers, University of Frankfurt/Main,
% <j.kremers@em.uni-frankfurt.de>, has kindfully defined a "generalised
% branch" command that I happily integrate here:

\newcommand{\GBkk}[4]{\POS[]-(0,4)+(#1)\ar@{#4}[#3]+(0,2)+(#2)}
\newcommand{\GBk}[4]{\GBkk{0,#1}{0,#2}{#3}{#4}}
\newcommand{\GB}[3][0]{\GBk{#1}{0}{#2}{#3}}

% The branch commands are the same as the \Bkk, \Bk and \B commands, except
% that they have one more mandatory argument, and the first mandatory argument
% is the line style, which can be as follows:

% - solid line
% -- dashed line
% = double line
% == dashed double line
% . dotted line
% : dotted double line
% ~ wavy line
% ~~ dashed wavy line




% Here come a couple of abbreviations for often used branching commands:

% \D goes to the position in the same column, one row below. The optional
% argument is the vertical adjustment of the starting position.

\newcommand{\D}[1][0]{\B[#1]{d}} 
\newcommand{\Dk}[2]{\Bk{#1}{#2}{d}}

% \Dk is the \Bk version, i.e., it has two obligatory arguments defining the
% vertical adjustments of starting position and target position.

\newcommand{\DL}[1][0]{\B[#1]{dl}} 
\newcommand{\DLL}[1][0]{\B[#1]{dll}} 
\newcommand{\DLLL}[1][0]{\B[#1]{dlll}} 
\newcommand{\DR}[1][0]{\B[#1]{dr}} 
\newcommand{\DRR}[1][0]{\B[#1]{drr}} 
\newcommand{\DRRR}[1][0]{\B[#1]{drrr}} 

\newcommand{\DLk}[2][0]{\Bk{#1}{#2}{dl}} 
\newcommand{\DLLk}[2][0]{\Bk{#1}{#2}{dll}} 
\newcommand{\DLLLk}[2][0]{\Bk{#1}{#2}{dlll}} 
\newcommand{\DRk}[2][0]{\Bk{#1}{#2}{dr}} 
\newcommand{\DRRk}[2][0]{\Bk{#1}{#2}{drr}} 
\newcommand{\DRRRk}[2][0]{\Bk{#1}{#2}{drrr}} 


% Abbreviations for binary branches:


\newcommand{\V}[1][0]{\DL[#1]\DR[#1]}
\newcommand{\VV}[1][0]{\DLL[#1]\DRR[#1]}
\newcommand{\VR}[1][0]{\DL[#1]\DRR[#1]}
\newcommand{\VL}[1][0]{\DLL[#1]\DR[#1]}
\newcommand{\VVV}[1][0]{\DLLL[#1]\DRRR[#1]}
\newcommand{\VVR}[1][0]{\DLL[#1]\DRRR[#1]}
\newcommand{\VVL}[1][0]{\DLLL[#1]\DRR[#1]}
\newcommand{\VLL}[1][0]{\DLLL[#1]\DR[#1]}
\newcommand{\VRR}[1][0]{\DL[#1]\DRRR[#1]}

% Define more if you need them.

% Let's make further abbreviations. A default VP has a \V branch. So let's
% define \VP accordingly, and likewise Vbar, IP, CP etc.:

\newcommand{\VP}[1][]{\K{VP$_{#1}$}\V}
\newcommand{\Vbar}{\K[.5]{V$'$}\V}

\newcommand{\IP}[1][]{\K{IP$_{#1}$}\V}
\newcommand{\Ibar}{\K[.5]{I$'$}\V}

\newcommand{\CP}[1][]{\K{CP$_{#1}$}\V}
\newcommand{\Cbar}{\K[.5]{C$'$}\V}
\newcommand{\Nbar}{\K[.5]{N$'$}\V}

\newcommand{\PP}[1][]{\K{PP$_{#1}$}\V}
\newcommand{\DP}[1][]{\K{DP$_{#1}$}\V}

\newcommand{\AuxP}[1][]{\K{IP$_{#1}$}\V}
\newcommand{\Auxbar}{\K[.5]{I$'$}\V}

% Nodes reasonably without branch:

\newcommand{\NP}[1][]{\K{NP$_{#1}$}}
\newcommand{\Nzero}[1][]{\K[1]{N$^{0}_{#1}$}}
\newcommand{\Vzero}[1][]{\K[1]{V$^{0}_{#1}$}}
\newcommand{\Izero}[1][]{\K{I$^{0}_{#1}$}}
\newcommand{\Auxzero}[1][]{\K{I$^{0}_{#1}$}}
\newcommand{\Czero}[1][]{\K{C$^{0}_{#1}$}}
\newcommand{\Pzero}[1][]{\K{P$^{0}_{#1}$}}
\newcommand{\Dzero}[1][]{\K{D$^{0}_{#1}$}}

% Note that all of these commands, except for the Xbar nodes, have an optional
% argument for an index. If you use indices longer than one letter, you might
% need to do horizontal adjustment and have to use \K instead.

% This default system only needs new nodes for the terminals. Let's define \T
% parallel to \K. \T has a vertical branch to the upper node, text is
% italicised. The optional argument, as before, allows for 
% horizontal adjustment of the text:

\newcommand{\T}[2][0]{\POS[]\POS+(0,2) \ar@{-}[u]-(0,4)%
\POS[]\K[#1]{\textit{#2}}}

% An entry could consist of several rows, especially terminal nodes, but we don't
% want them to influence the lengths of branches. The following defines entries
% that are typed below an entry. It can be used repeatedly:

\newcommand{\Below}[2][0]{\POS-(0,5)+(0,#1)%
\save*\hbox{\textnormal{\rule[-6pt]{0pt}{18pt}%
#2}}\restore}

% The optional argument is the vertical distance to the upper entry. 
% \below[vertical]{blablabla}

\newcommand{\Belowk}[3][4]{\POS+(#2,#1)%
\save*\hbox{\textnormal{\rule[-6pt]{0pt}{18pt}%
#3}}\restore}

% \Belowk command has an additional obligatory argument for horizontal
% adjustment: \Belowk[vertical]{horizontal}{blablabla}

% Let's define a trace:

\newcommand{\Trace}[1][i]{\K[0.5]{t$_{#1}$}}


% Alternative phrase structure tree commands can easily be built with \Treek,
% \Bkk and \Kk. These are LFG macros:

\newcommand{\Treelfg}[2][0]{\Treek[#1]{3}{#2}} 
\newcommand{\Klfg}[2][]{\K{$\uparrow _{\textsc{\scriptsize #1}}=\downarrow$}\Below{#2}} 
\newcommand{\Blfg}[1]{\Bk{-5}{0}{#1}}
\newcommand{\Vlfg}{\Blfg{dl}\Blfg{dr}}

% Note that \Klfg produces two lines: The inheritance specification and the
% category label. The optional argument is the grammatical function, which, if
% available is indexed to the $\uparrow$ in the first line.

% This completes the basics of our trees with the most frequently used
% functions. Now come some  extensions, in particular, circled nodes with
% adjusted branches, triangles and arrows linking nodes.


% Here come some coloured versions of \K and \B:

\RequirePackage{color}
\definecolor{gray}{gray}{.5}
\newcommand{\Kkblue}[3][0]{%
  \POS[]+(#1,-1.5)+(0,#2) \save*\txt{\textnormal{\rule[-6pt]{0pt}{18pt}\color{blue}#3}}
  \restore}
\newcommand{\Kblue}[2][0]{%
  \Kk[#1]{0}{\color{blue}#2}}

\newcommand{\Kkred}[3][0]{%
  \POS[]+(#1,-1.5)+(0,#2) \save*\txt{\textnormal{\rule[-6pt]{0pt}{18pt}\color{red}#3}}
  \restore}
\newcommand{\Kred}[2][0]{%
  \Kk[#1]{0}{\color{red}#2}}

\newcommand{\Kkgreen}[3][0]{%
  \POS[]+(#1,-1.5)+(0,#2) \save*\txt{\textnormal{\rule[-6pt]{0pt}{18pt}\color{green}#3}}
  \restore}
\newcommand{\Kgreen}[2][0]{%
  \Kk[#1]{0}{\color{green}#2}}

\newcommand{\Kkgray}[3][0]{%
  \POS[]+(#1,-1.5)+(0,#2) \save*\txt{\textnormal{\rule[-6pt]{0pt}{18pt}\color{gray}#3}}
  \restore}
\newcommand{\Kgray}[2][0]{%
  \Kk[#1]{0}{\color{gray}#2}}

\newcommand{\Bkkblue}[3]{%
  \POS[]-(0,4)+(#1)\ar@{-}@[blue][#3]+(0,2)+(#2)}
\newcommand{\Bkblue}[3]{%
\Bkkblue{0,#1}{0,#2}{#3}}
\newcommand{\Bblue}[2][0]{\Bkblue{#1}{0}{#2}}

\newcommand{\Bkkred}[3]{%
  \POS[]-(0,4)+(#1)\ar@{-}@[red][#3]+(0,2)+(#2)}
\newcommand{\Bkred}[3]{%
\Bkkred{0,#1}{0,#2}{#3}}
\newcommand{\Bred}[2][0]{\Bkred{#1}{0}{#2}}

\newcommand{\Bkkgreen}[3]{%
  \POS[]-(0,4)+(#1)\ar@{-}@[green][#3]+(0,2)+(#2)}
\newcommand{\Bkgreen}[3]{%
\Bkkgreen{0,#1}{0,#2}{#3}}
\newcommand{\Bgreen}[2][0]{\Bkgreen{#1}{0}{#2}}

\newcommand{\Bkkgray}[3]{%
  \POS[]-(0,4)+(#1)\ar@{-}@[gray][#3]+(0,2)+(#2)}
\newcommand{\Bkgray}[3]{%
\Bkkgray{0,#1}{0,#2}{#3}}
\newcommand{\Bgray}[2][0]{\Bkgray{#1}{0}{#2}}

\newcommand{\Vblue}{\Bblue{dl}\Bblue{dr}}
\newcommand{\Vred}{\Bred{dl}\Bred{dr}}
\newcommand{\Vgreen}{\Bgreen{dl}\Bgreen{dr}}
\newcommand{\Vgray}{\Bgray{dl}\Bgray{dr}}

\newcommand{\Tblue}[2][0]{\POS[]\POS+(0,2) \ar@{-}@[blue][u]-(0,4)%
\K[#1]{\textit{\color{blue}#2}}}
\newcommand{\Tred}[2][0]{\POS[]\POS+(0,2) \ar@{-}@[red][u]-(0,4)%
\K[#1]{\textit{\color{red}#2}}}
\newcommand{\Tgreen}[2][0]{\POS[]\POS+(0,2) \ar@{-}@[green][u]-(0,4)%
\K[#1]{\textit{\color{green}#2}}}
\newcommand{\Tgray}[2][0]{\POS[]\POS+(0,2) \ar@{-}@[gray][u]-(0,4)%
\K[#1]{\textit{\color{gray}#2}}}

% Coloured versions of arrows, just examples. They are made a bit
% thicker. This is useful in pdf presentations, e.g. with seminar.sty or
% prosper.sty:

\newcommand{\ARblue}[2][0]{\POS[]\POS-(0,4)\POS+(0,#1) \ar@[Blue]@[thicker][#2]+(0,2)}
\newcommand{\ARdotblue}[2][0]{\POS[]\POS-(0,4)\POS+(0,#1) \ar@[Blue]@[thicker]@{.>}[#2]+(0,2)}
\newcommand{\ARdashblue}[2][0]{\POS[]\POS-(0,4)\POS+(0,#1) \ar@[Blue]@[thicker]@{-->}[#2]+(0,2)}

\newcommand{\ARred}[2][0]{\POS[]\POS-(0,4)\POS+(0,#1) \ar@[Red]@[thicker][#2]+(0,2)}
\newcommand{\ARdotred}[2][0]{\POS[]\POS-(0,4)\POS+(0,#1) \ar@[Red]@[thicker]@{.>}[#2]+(0,2)}
\newcommand{\ARdashred}[2][0]{\POS[]\POS-(0,4)\POS+(0,#1) \ar@[Red]@[thicker]@{-->}[#2]+(0,2)}


% Extension Nr. 1:
% Circles and squares around nodes with branches:

% First, we define the circle, to be added after the \K{}, like the branch. It
% is designed to fit two-letter nodes, like VP a.o. Optional argument: line
% style: dot . for dotted, dash - for dashed, nothing for solid.

\newcommand{\OO}[1][]{\POS[]+(0,-1)\drop\frm<1pc>{#1o}}

% the radius of the circle is set to 1pc. if you need a different radius,
% use \OOk. In addition to the optional line style argument, it has an
% obligatory argument for the radius.

\newcommand{\OOk}[2][]{ \POS[]+(0,-1)\drop\frm<#2pc>{#1o}}

% Colored versions:

\newcommand{\OOred}[2][o]{{}\POS[]+(0,-1)\save *+<2pc>[#1][F:red]\txt{}\restore}
\newcommand{\OOblue}[2][o]{{}\POS[]+(0,-1)\save *+<2pc>[#1][F:blue]\txt{}\restore}
\newcommand{\OOgreen}[2][o]{{}\POS[]+(0,-1)\save *+<2pc>[#1][F:green]\txt{}\restore}
\newcommand{\OOgray}[2][o]{{}\POS[]+(0,-1)\save *+<2pc>[#1][F:gray]\txt{}\restore}

%% This is hacked: must be first in the field, before the \K command, and
%% followed by an empty group, {}.

% Now comes the boring stuff. Branches that start or end at circles are
% shorter. So let's define macros for all kinds of  short branches. Some
% commands include the circles already.

% This is a branch that always works, starting point for all branches is the
% same point on the circle. This makes branches rather short, and changes their 
% angle:

\newcommand{\BoO}[1]{\Bk{-1.2}{1.2}{#1}} % branch with circled start and target,
                                        % from middle position
\newcommand{\Bo}[1]{\Bk{-1.2}{0}{#1}} % branch with circled start,
                                        % from middle position
\newcommand{\BO}[1]{\Bk{0}{1.2}{#1}} % branch with circled target,
                                    % from middle position


\newcommand{\Do}{\Dk{-1.2}{0}} % only circled starting node
\newcommand{\DO}{\Dk{0}{1.2}} % only circled target 
\newcommand{\DoO}{\Dk{-1.2}{1.2}} % circled start and target

\newcommand{\ODO}{\OO\DoO} % circle plus downwards branch to circled node
\newcommand{\OD}{\OO\Do} % Circle with downwards branch

\newcommand{\DRo}[1][dr]{\Bkk{1.5,-.9}{0,0}{#1}}
\newcommand{\DLo}[1][dl]{\Bkk{-1.5,-.9}{0,0}{#1}}

\newcommand{\DRoO}[1][dr]{\Bkk{1.5,-.9}{-1.8,1}{#1}}
\newcommand{\DLoO}[1][dl]{\Bkk{-1.5,-.9}{1.8,1}{#1}}

\newcommand{\DRO}[1][dr]{\Bkk{0,0}{-1.8,1}{#1}}
\newcommand{\DLO}[1][dl]{\Bkk{0,0}{1.8,1}{#1}}

\newcommand{\DRRo}{\DRo[drr]}
\newcommand{\DLLo}{\DLo[dll]}

\newcommand{\DRRoO}{\DRoO[drr]}
\newcommand{\DLLoO}{\DLoO[dll]}

\newcommand{\DRRO}{\DRO[drr]}
\newcommand{\DLLO}{\DLO[dll]}

\newcommand{\DRRRo}{\DRo[drrr]}
\newcommand{\DLLLo}{\DLo[dlll]}

\newcommand{\DRRRoO}{\DRoO[drrr]}
\newcommand{\DLLLoO}{\DLoO[dlll]}

\newcommand{\DRRRO}{\DRO[drrr]}
\newcommand{\DLLLO}{\DLO[dlll]}

\newcommand{\VoO}{\DLO\DRO} % uncircled starting node, circled targets left
                            % and right
\newcommand{\VO}{\DL\DRO}   % circled right target only
\newcommand{\Vo}{\DLO\DR}   % circled left target only

\newcommand{\VVoO}{\DLLO\DRRO} % same as above, two steps left/right
\newcommand{\VVO}{\DLL\DRRO}
\newcommand{\VVo}{\DLLO\DRR}

\newcommand{\VVVoO}{\DLLLO\DRRRO} % same as above, three steps left/right
\newcommand{\VVVO}{\DLLL\DRRRO}
\newcommand{\VVVo}{\DLLLO\DRRR}

\newcommand{\OV}{\OO\DLo\DRo}     % circle plus branches from circled
                                  % starting node 
\newcommand{\OVoO}{\OO\DLoO\DRoO} % circled targets
\newcommand{\OVO}{\OO\DLo\DRoO}   % circled right target
\newcommand{\OVo}{\OO\DLoO\DRo}   % circled left target

% Define more, if you need them!

% For instance, how about a square instead of a circle:

\newcommand{\QQ}[1][-]{\POS[]+(0,-1)-(4,4);\POS[]+(0,-1)+(4,4)**\frm{#1}}

% And coloured versions:

\newcommand{\QQred}[2][o]{{}\POS[]+(0,-1)\save *+<1.9pc>[#1][F:red]\txt{}\restore}
\newcommand{\QQblue}[2][o]{{}\POS[]+(0,-1)\save *+<1.9pc>[#1][F:blue]\txt{}\restore}
\newcommand{\QQgreen}[2][o]{{}\POS[]+(0,-1)\save *+<1.9pc>[#1][F:green]\txt{}\restore}
\newcommand{\QQgray}[2][o]{{}\POS[]+(0,-1)\save *+<1.9pc>[#1][F:gray]\txt{}\restore}

% Again: These are not fully functioning. It only works, if the \QQ<color>
% command is the first one in the field, right after the &, and is followed by
% an empty group {}. 

% you need branches to and from squared nodes:

\newcommand{\DRq}[1][dr]{\Bkk{1.5,-1}{0,0}{#1}}
\newcommand{\DLq}[1][dl]{\Bkk{-1.5,-1}{0,0}{#1}}

\newcommand{\DRQ}[1][dr]{\Bkk{0,0}{-2,1}{#1}}
\newcommand{\DLQ}[1][dl]{\Bkk{0,0}{2,1}{#1}}

\newcommand{\DRqQ}[1][dr]{\Bkk{1.5,-1}{-2,1}{#1}}
\newcommand{\DLqQ}[1][dl]{\Bkk{1.5,-1}{2,1}{#1}}

\newcommand{\DRoQ}[1][dr]{\Bkk{1.5,-.9}{-2,1}{#1}}
\newcommand{\DLoQ}[1][dl]{\Bkk{-1.5,-.9}{2,1}{#1}}

\newcommand{\DRqO}[1][dr]{\Bkk{1.6,-1}{-1.8,1}{#1}}
\newcommand{\DLqO}[1][dl]{\Bkk{1.6,-1}{1.8,1}{#1}}

\newcommand{\Dq}{\Dk{-1.1}{0}} % only squared starting node
\newcommand{\DQ}{\Dk{0}{1}} % only squared target node
\newcommand{\DqO}{\Dk{-1.1}{1.2}} % squared start and circled target
\newcommand{\DoQ}{\Dk{-1.3}{1}} % circled start and squared target
\newcommand{\DqQ}{\Dk{-1.1}{1}} % square start and squared target


% Sometimes, it is useful to highlight sections of the tree with a
% rectangle. Let's define such a rectangle:

\newcommand{\QS}[3][-]{{}\POS"#2";\POS"#3"+(4,-4)**\frm{#1}}

% Syntax: \QS[line style]{absolue address of top left corner}{absolue address of
% bottom right corner}
% The absolute address is a number pair: Field 1,1 is the top left field. The
% fields in the first row are 1,1 1,2 1,3 etc. Those in the second row
% 2,1 2,2 2,3 etc. 

% Extension 2:
% Drawing links between nodes

% We have two versions, one version, \Link, for links drawn below the
% tree, and one for links drawn above the tree, \UpLink. The kontrolled
% version is \Linkk / \UpLinkk:

\newcommand{\Linkk}[3][->]{%
\POS[]-(3.33,2) \ar@{#1}@/^{#2pc}/[#3]-(1,3.33)} 

\newcommand{\UpLinkk}[3][->]{%
\POS[]+(1.33,2) \ar@{#1}@/_{#2pc}/[#3]+(2,-2)} 

% \Linkk[style]{curving}{target}
% The curving ratio controls the curving of the link. In the commands \Link
% and \UpLink, it is defaulted to 1.33. The curving will differ from tree
% to tree, so a default might be quite useless.
% Style can be . for dotted, - for solid, -- for dashed, with leading or
% following < or > for the arrows. Default is a solid arrow to the target, `->'.  

% Links are defined such that they point from the lower position in the tree
% to the higher position, not the other way around. But it's all a matter of
% where they initiate relative to their source and target fields (left/right,
% top/bottom). Redefine it for your needs.

\newcommand{\Link}[2][->]{%
  \Linkk[#1]{1.33}{#2}}

\newcommand{\UpLink}[2][->]{%
\UpLinkk[#1]{1.33}{#2}} 

% Syntax: \Link[style]{target}

%% Extension in version 1.0.1: adjusting starting and target postions:

\newcommand{\LINKK}[5][->]{%
\POS[]-(3.33,2)+(#4) \ar@{#1}@/^{#2pc}/[#3]-(1,3.33)+(#5)} 

\newcommand{\UPLINKK}[5][->]{%
\POS[]+(1.33,2)+(#4) \ar@{#1}@/_{#2pc}/[#3]+(2,-2)+(#5)} 

\newcommand{\LINK}[4][->]{%
  \LINKK[#1]{1.33}{#2}{#3}{#4}}

\newcommand{\UPLINK}[4][->]{%
\UpLinkk[#1]{1.33}{#2}{#3}{#4}} 

% argument number 4 and 5 are comma separated value pairs for the x and y
% dimensions. 


% Here come red and blue links. Might be useful for pdf presentations:

\newcommand{\Linkkblue}[3][->]{%
\POS[]-(3.33,2) \ar@[Blue]@[thicker]@{#1}@/^{#2pc}/[#3]-(1,3.33)} 

\newcommand{\Linkblue}[2][->]{%
\Linkkblue[#1]{1.33}{#2}} 

\newcommand{\Linkkred}[3][->]{%
\POS[]-(3.33,2) \ar@[Red]@[thicker]@{#1}@/^{#2pc}/[#3]-(1,3.33)} 

\newcommand{\Linkred}[2][->]{%
\Linkkred[#1]{1.33}{#2}} 


% Links between circled nodes:

\newcommand{\LinkkoO}[3][->]{%
\POS[]-(4.25,2) \ar@{#1}@/^{#2pc}/[#3]-(0,6)} 

\newcommand{\UpLinkkoO}[3][->]{%
\POS[]-(3.33,-2) \ar@{#1}@/_{#2pc}/[#3]+(4,-2)} 

% Link starting at circle

\newcommand{\Linkko}[3][->]{%
\POS[]-(4.25,2) \ar@{#1}@/^{#2pc}/[#3]-(1,3.33)} 

% Link targeting circle

\newcommand{\LinkkO}[3][->]{%
\POS[]-(3.33,2) \ar@{#1}@/^{#2pc}/[#3]-(0,6)} 



% This is included from the older documentation:

% Advanced usage of arrows: study the examples, and read the xypic documentation
% for further details:

% \baum{ & \K{VP}\V \\
%  \K{V} \POS[]+(2,0)\ar[r] \POS[]+(-1,2)
%  \ar@{.>}@/^/[ur]-(2.5,0) 
%  && \K{NP} \POS[]-(3,0) \ar[l]
%  \ar@{-->}@/_{2pc}/[ul]_{\textsc{agr}} 
%  \POS[]-(2,2)\ar@{<-}@/^/[ll]-(0,2)_{\textsc{\tiny case}} 
% }

% \POS[] is the position of the actual entry
% \POS"1,1" is the position of the entry in row 1, column 1.
% \POS[dl] is the position one step down, one step left from current position
% an arrow consists of an optional start position, the command \ar wit
% modifiers, and a target position (the target is written without \POS. the
% simplest arrow is like \ar[l] or \ar[dr] etc. several modifiers are possible:
% @{style}, where style is:
% @{.} dotted line | @{-} line | @{--} dashed line
% these can be combined with arrows, symbolized by < and >:
% @{.>} , @{<--} etc.
% the arrow can be curved, modifiers:
% @/_/ downwards curved , @/^/ upwards curved
% an optional argument makes wider or narrower curves:
% @/_{3pt}/ @/^{3pc}/ etc
% arrow labels can occur above or below the arrow:
% _{text} , ^{text}
% \POS[]+(-1,2) \ar@{-->}@/_{2pc}/[ul]_{\textsc{agr}}
% start pos.    |  |     |        |   |
%            arrow sty  curve  target label
%            commd. le         pos.

% frames

%  \Tree{ & {}\drop\frm<0.8pc>{-o} \K{VP} \POS[]-(0,4)\ar@{-}[dl]+(2,2)
%    \POS[]-(0,4)\ar@{-}[dr]  \\ 
%    \K{V} && {}\POS[]-(3,3);\POS+(3,3)**\frm{.} \K{NP}
%    \POS[]+(6,2);\POS[ll]-(2,2)**\frm<8pt>{-}}  


% Extension 3:
% Triangles

% Triangles need the nodes they refer to in the next lower row, in particular,
% don't forget the node [d] from the insertion point of the triangle. You will
% get an error otherwise. The text below the triangle is to be inserted in the
% field [d] from the insertion point.  

% The fully kontrolled command \TRikk has three arguments. The two obligatory
% arguments for horizontal adjustments of the left and right edge of the
% triangle, and the optional argument for the vertical adjustment:

% \TRikk[vertical]{left}{right}
\newcommand{\TRikk}[3][0]{%
\POS[d]+(-10.4,0)+(-#2,2)+(0,#1)\ar@{-}[d]+(10.4,0)+(#3,2)+(0,#1)
\POS[]\POS+(0,-4);\POS[d]\POS+(-10.4,0)+(-#2,2)+(0,#1)**\dir{-}%
\POS[]\POS+(0,-4);\POS[d]\POS+(10.4,0)\POS+(#3,2)+(0,#1)**\dir{-}%
}

% Simpler commands are defined on the basis of \TRikk. \TRik has no vertical
% adjustment: 

\newcommand{\TRik}[2]{\TRikk{#1}{#2}}

% Syntax: \TRik{left}{right}

% \TRi is a symmetric triangle with the optional argument of the horizontal
% adjustment, negative value makes it narrower, positive value makes it wider.

\newcommand{\TRi}[1][0]{\TRik{#1}{#1}}

% \TRi[left/right]

% Note: \TRikk{0}{0} = \TRik{0}{0} = \TRi

% These triangles are rectangles, DTRi has a [d] branch on the left, \TRiD on
% the right:

\newcommand{\DTRi}[1][0]{\TRik{-10.4}{#1}}
\newcommand{\TRiD}[1][0]{\TRik{#1}{-10.4}}


% Extension 4: Sideways branches and arrows:

\newcommand{\R}[2][-]{\POS[]+(3.7,-1.2)\ar@{#1}[#2]-(3.7,1.2)}
\newcommand{\RoO}[2][-]{\POS[]+(4.2,-1.2)\ar@{#1}[#2]-(4.2,1.2)}
\newcommand{\Ro}[2][-]{\POS[]+(4.2,-1.2)\ar@{#1}[#2]-(3.7,1.2)}
\newcommand{\RO}[2][-]{\POS[]+(3.7,-1.2)\ar@{#1}[#2]-(4.2,1.2)}

\newcommand{\RqQ}[2][-]{\POS[]+(4,-1.2)\ar@{#1}[#2]-(4,1.2)}
\newcommand{\Rq}[2][-]{\POS[]+(4,-1.2)\ar@{#1}[#2]-(3.7,1.2)}
\newcommand{\RQ}[2][-]{\POS[]+(3.7,-1.2)\ar@{#1}[#2]-(4,1.2)}

\newcommand{\RoQ}[2][-]{\POS[]+(4.2,-1.2)\ar@{#1}[#2]-(4,1.2)}
\newcommand{\RqO}[2][-]{\POS[]+(4,-1.2)\ar@{#1}[#2]-(4.2,1.2)}

%% New in 1.0.1: \Rk and \Rkk
\newcommand{\Rkk}[4][-]{\POS[]+(3.7,-1.2)+(#3)\ar@{#1}[#2]-(3.7,1.2)+(#4)}
\newcommand{\Rk}[4][-]{\POS[]+(3.7,-1.2)+(#3,0)\ar@{#1}[#2]-(3.7,1.2)+(#4,0)}
\newcommand{\Rkt}[4][-]{\POS[]+(3.7,-1.2)+(#3,0)\ar@[|(2)]@{#1}[#2]-(3.7,1.2)+(#4,0)}

% Extension 5:
% Arrows in bracketed notations of syntactic structures

% This requires a new matrix, we call it \TExt. Here the inter-column space is
% set to zero. This means that we have horizontal space with the insertion of
% a `&'. I.e., we could let arrows point to letters within words.  The
% controlled version, \Textk, allows you to control for inter-column space
% with the first mandatory argument. The optional argument adjusts inter-row
% space.

\newcommand{\TExtk}[3][0]{\raisebox{3pt}{\xymatrix @R=#1pc @C=0pt @M=#2pc {#3}}}
\newcommand{\TExt}[2][0]{\TExtk{0}{#2}}

% \TExtk has three arguments:
% \Textk[inter row distance]{inter column distance}{matrix}

% The fields within the \TExt environment are inserted with \Txt or \TXT. They
% mainly provide a strut to yield correct horizontal alignment. \Txt has a
% blank before the text, \TXT has none. I.e., if a word is split over two
% fields, the second part of the word should be introduced with \TXT.
% Likewise, the first word:

\newcommand{\Txt}[1]{\txt{\rule[-6pt]{0pt}{18pt} #1}}
\newcommand{\TXT}[1]{\txt{\rule[-6pt]{0pt}{18pt}#1}}

% Here come the arrows, they differ in their depths, such that several arrows
% can be used within one \TExt without overlapping:

\newcommand{\COn}[2][-]{%
\POS[]+(0,-2);\POS[]+(0,-6)**\dir{#1} \POS[]+(0,-6);\POS[#2]+(0,-6)**\dir{#1}
\POS[#2]+(0,-6) \ar@{#1>}[#2]+(0,-2)}
\newcommand{\COnn}[2][-]{%
\POS[]+(0,-2);\POS[]+(0,-8)**\dir{#1} \POS[]+(0,-8);\POS[#2]+(0,-8)**\dir{#1}
\POS[#2]+(0,-8) \ar@{#1>}[#2]+(0,-2)}
\newcommand{\COnnn}[2][-]{%
\POS[]+(0,-2);\POS[]+(0,-10)**\dir{#1} \POS[]+(0,-10);\POS[#2]+(0,-10)**\dir{#1}
\POS[#2]+(0,-10) \ar@{#1>}[#2]+(0,-2)}

% Syntax: \COn[style]{target}
% SCOn is a small connector:

\newcommand{\SCOn}[2][-]{%
\POS[]+(0,-2);\POS[]+(0,-5)**\dir{#1} \POS[]+(0,-5);\POS[#2]+(0,-5)**\dir{#1}
\POS[#2]+(0,-5) \ar@{#1>}[#2]+(0,-2)}

\newcommand{\COnk}[3][-]{%
\POS[]+(0,-2);\POS[]+(0,-#2)**\dir{#1} \POS[]+(0,-#2);\POS[#3]+(0,-#2)**\dir{#1}
\POS[#3]+(0,-#2) \ar@{#1>}[#3]+(0,-2)}

% Example:
%
% \TExt{\TXT{What} & \Txt{did you see} & \Txt{t}\COn{ll} & \Txt{?}}
% 

% Connectors with labels, above or below (depending on whether the arrow goes
% from left to right or vice versa, \COnl with left to right gives label below
% the arrow):

\newcommand{\COnl}[3][-]{%
\POS[]+(0,-2)\ar@{#1}[]+(0,-6) \POS[]+(0,-6) \ar@{#1}[#2]+(0,-6)_{#3}
\POS[#2]+(0,-6) \ar@{#1>}[#2]+(0,-2)}

\newcommand{\COnr}[3][-]{%
\POS[]+(0,-2)\ar@{#1}[]+(0,-6) \POS[]+(0,-6) \ar@{#1}[#2]+(0,-6)^{#3}
\POS[#2]+(0,-6) \ar@{#1>}[#2]+(0,-2)}

% Syntax: \COnl[style]{target}{label}



%%% Autosegmental Phonology: Tier structures
% We have to define links and slots. The slot command is \Slk in its
% kontrolled version: 

\newcommand{\Slk}[3][0]{%
  \POS[]+(#1,0)+(0,#2) \save*\txt{\textnormal{\rule[-6pt]{0pt}{18pt}#3}}
  \restore}

% Syntax \Slk[horizontal displaycement]{vertical displacement}{text}

\newcommand{\Sl}[2][0]{%
  \Slk[#1]{0}{#2}}

% \Sl[horizontal displacement]{text}
% Sometimes we want to give names to the tiers/rows:

\newcommand{\Tname}[2][3]{%
  \Slk{0}{\makebox[#1cm][l]{#2\rule[-6pt]{0pt}{18pt}}}}

% \Tname[name width]{name text}

% This command provides a de-link, i.e. strikes through a downwards line with
% a '='.

\newcommand{\Del}[1][4.825]{\Slk{#1}{=}}

% Links

\newcommand{\Lnk}[3]{\Bkk{0,#1}{0,#2}{#3}}
\newcommand{\Ln}[2][7]{\Lnk{#1}{-4}{#2}}

\newcommand{\Lnd}[2][0]{\POS[]+(0,3)\POS+(0,#1)\ar@{--}[#2]+(0,-2)}
\newcommand{\Lnu}{\Ln{u}}
\newcommand{\Lndu}{\Lnd{u}}






% old stuff - some backwards compatibility:

\let\M\D
\let\Mk\Dk
\let\LL\DL
\let\LLk\DLk
\let\LLL\DLL
\let\RR\DR
\let\RRk\DRk
\let\RRR\DRR

\let\baum\Tree
\let\drunter\Below
\let\DRUNTER\BELOW
\let\ATRi\TRik
\let\BELOW\Belowk
\let\CON\COnk

%% Extras: Metrical Grids
\RequirePackage{ifthen}

\newcounter{PXcnt}
\newcommand{\PX}[2][1]{%
\shortstack[c]{%
\whiledo{\value{PXcnt}<#1}
{\stepcounter{PXcnt}$\times$\\}#2\strut%
}\setcounter{PXcnt}{0}}

\newcommand{\PXl}[2][1]{%
\shortstack[l]{%
\whiledo{\value{PXcnt}<#1}
{\stepcounter{PXcnt}$\times$\\}#2\strut%
}\setcounter{PXcnt}{0}}

\newcommand{\PXr}[2][1]{%
\shortstack[r]{%
\whiledo{\value{PXcnt}<#1}
{\stepcounter{PXcnt}$\times$\\}#2\strut%
}\setcounter{PXcnt}{0}}


% Syntax: \PX[number of grid marks]{expression}
% An example:
%          \PX[2]{Fa}rah \PX{Faw}cett \PX[3]{Ma}jors


%% Single word glosses:

\newlength{\TXTwidth}
\newlength{\GLOSSwidth}
\newlength{\PGwidth}

% Default is left alignment:
\newcommand{\PG}[2]{%
\settowidth{\TXTwidth}{#1}%
\settowidth{\GLOSSwidth}{#2}%
\ifthenelse{\lengthtest{\TXTwidth > \GLOSSwidth}}%
{\settowidth{\PGwidth}{#1}}{\settowidth{\PGwidth}{#2}}%
\begin{minipage}[t]{\PGwidth}
\raggedright
#1 \\ #2
\end{minipage}\smallskip%
}

% This is center alignment:
\newcommand{\PGc}[2]{%
\settowidth{\TXTwidth}{#1}%
\settowidth{\GLOSSwidth}{#2}%
\ifthenelse{\lengthtest{\TXTwidth > \GLOSSwidth}}%
{\settowidth{\PGwidth}{#1}}{\settowidth{\PGwidth}{#2}}%
\begin{minipage}[t]{\PGwidth}
\centering
#1 \\ #2
\end{minipage}\smallskip%
}

% This is right alignment:

\newcommand{\PGr}[2]{%
\settowidth{\TXTwidth}{#1}%
\settowidth{\GLOSSwidth}{#2}%
\ifthenelse{\lengthtest{\TXTwidth > \GLOSSwidth}}%
{\settowidth{\PGwidth}{#1}}{\settowidth{\PGwidth}{#2}}%
\begin{minipage}[t]{\PGwidth}
\raggedleft
#1 \\ #2
\end{minipage}\smallskip
}

% Syntax: \PG{word}{gloss}


% Out of use: metrical grids.
%% \newcommand{\Grid}[2][0]{\raisebox{1ex}{\xymatrix @R=.5pc @C=#1pc {#2}}}
%% \newcommand{\Gtxt}[1]{\txt{\rule[-6pt]{0pt}{18pt} #1}}


% Comments and suggestions: rvogel@ling.uni-potsdam.de
% http://www.ling.uni-potsdam.de/~rvogel/xyling

